<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Topdown - Coming Soon</title>
    <style>
      body {
        margin: 0;
        position: relative;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
      }
      svg {
        border-radius: 10px;
      }

      #wrapper {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 300px;
        height: 300px;
        background: radial-gradient(
          circle,
          transparent 0%,
          transparent 100%,
          rgba(255, 255, 255, 0.1) 100%,
          rgba(255, 255, 255, 0.1) 100%
        );
        animation: pulse 3s infinite;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        filter: blur(10px);
      }

      #wrapper::before {
        content: "";
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 150%;
        height: 150%;
        border-radius: 50%;
        background: radial-gradient(circle, #ffffff 0%, transparent 50%);
      }

      img {
        max-width: 80%;
        max-height: 80%;
        object-fit: contain;
        transform: scale(1);
      }

      .logo {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) rotateY(0deg);
  width: 250px;
  height: auto;
  z-index: 1;
  backface-visibility: hidden;
}

#toggleImg {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) rotateY(180deg);
  width: 250px;
  height: auto;
  backface-visibility: hidden;
  transition: transform 0.5s;
}

#toggleImg.show {
  opacity: 1; /* Set opacity to 1 to show the image */
  transform: translate(-50%, -50%) rotateY(0deg); /* Rotate the image around Y-axis by 180 degrees */
}




    .flip {
      animation: flip 0.5s;
      transform-style: preserve-3d;
    }

    @keyframes flip {
      0% {
        transform: rotateY(0);
      }
      50% {
        transform: rotateY(180deg);
      }
      100% {
        transform: rotateY(360deg);
      }
    }

      @keyframes pulse {
        0%,
        100% {
          background-color: rgba(155, 155, 155, 0.1);
        }
        50% {
          background-color: rgba(155, 155, 155, 0.3);
        }
      }
    </style>
  </head>
  <body>
    <div id="wrapper"></div>

    <img id="logo" src="https://i.imgur.com/OdOwV7x.png" alt="Topdown Logo" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) rotateY(0deg); width: 250px; height: auto; z-index: 1;" class="logo" onclick="toggleImage()" />



    <img id="toggleImg" src="https://i.imgur.com/1183oCx.png" alt="toggle image" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) rotateY(180deg); width: 250px; height: auto; opacity: 0; transition: opacity 0.5s ease-in-out, transform 0.5s ease-in-out;" class="flip show" />



    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      let scene,
        camera,
        renderer,
        spheres = [],
        raycaster,
        mouse;

      function init() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  );

  renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const geometry = new THREE.SphereGeometry(1, 32, 32);
  const material = new THREE.MeshPhongMaterial({
    color: 0x999999,
    shininess: 100,
  });

  const sphere1 = new THREE.Mesh(geometry, material);
  sphere1.position.set(-1, 0, 0);
  sphere1.velocity = new THREE.Vector3(
    (Math.random() - 0.5) * 0.0005,
    (Math.random() - 0.5) * 0.0005,
    (Math.random() - 0.5) * 0.0005
  );
  spheres.push(sphere1);
  scene.add(sphere1);

  const sphere2 = new THREE.Mesh(geometry, material);
  sphere2.position.set(1, 0, 0);
  sphere2.velocity = new THREE.Vector3(
    (Math.random() - 0.5) * 0.0005,
    (Math.random() - 0.5) * 0.0005,
    (Math.random() - 0.5) * 0.0005
  );
  spheres.push(sphere2);
  scene.add(sphere2);

  const sphere3 = new THREE.Mesh(geometry, material);
  sphere3.position.set(0, 0, 0);
  sphere3.velocity = new THREE.Vector3(
    (Math.random() - 0.5) * 0.0005,
    (Math.random() - 0.5) * 0.0005,
    (Math.random() - 0.5) * 0.0005
  );
  spheres.push(sphere3);
  scene.add(sphere3);

  const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
  scene.add(ambientLight);

  const pointLight = new THREE.PointLight(0xffffff, 1);
  pointLight.position.set(10, 10, 10);
  scene.add(pointLight);

  camera.position.z = 5;

  raycaster = new THREE.Raycaster();
  mouse = new THREE.Vector2();

  window.addEventListener("click", onClick, false);
  window.addEventListener("touchend", onClick, false);

  const toggleImg = document.getElementById("toggleImg");
  const topdownLogo = document.querySelector(".logo");
  topdownLogo.addEventListener("click", toggleImage);
  topdownLogo.addEventListener("touchend", toggleImage);
  toggleImg.addEventListener("click", function () {
    toggleImg.classList.add("flip");
    setTimeout(() => {
      toggleImg.classList.remove("flip");
      toggleImg.classList.toggle("show");
      const topdownLogo = document.querySelector(".logo");
      topdownLogo.style.display =
        topdownLogo.style.display === "none" ? "block" : "none";
    }, 500);
  });
  
  toggleImg.addEventListener("touchend", function () { // Add this block
  toggleImg.classList.add("flip");
  setTimeout(() => {
    toggleImg.classList.remove("flip");
    toggleImg.classList.toggle("show");
    const topdownLogo = document.querySelector(".logo");
    topdownLogo.style.display =
      topdownLogo.style.display === "none" ? "block" : "none";
  }, 500);
});

  toggleImg.addEventListener("animationend", function () {
    toggleImg.classList.remove("flip");
  });


  }
function toggleImage() {
  const toggleImg = document.getElementById("toggleImg");
  const topdownLogo = document.querySelector(".logo");
  const showClass = "show";
  const flipClass = "flip";

  // check if toggleImg is currently displayed
  if (toggleImg.classList.contains(showClass)) {
    // hide toggleImg
    toggleImg.classList.remove(showClass);

    // flip toggleImg
    toggleImg.classList.add(flipClass);
    setTimeout(() => {
      toggleImg.classList.remove(flipClass);

      // show topdownLogo
      topdownLogo.style.display = "block";
    }, 500);
  } else {
    // hide topdownLogo
    topdownLogo.style.display = "none";

    // flip toggleImg
    toggleImg.classList.add(flipClass);
    setTimeout(() => {
      toggleImg.classList.remove(flipClass);

      // show toggleImg
      toggleImg.classList.add(showClass);
    }, 500);
  }
}





















    function onClick(event) {
  event.preventDefault();

  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);

  const intersects = raycaster.intersectObjects(spheres);

  if (intersects.length > 0) {
    const clickedSphere = intersects[0].object;
    const scale = clickedSphere.scale.x / 2;

    const position = clickedSphere.position
      .clone()
      .add(clickedSphere.velocity.clone().multiplyScalar(1.5));

    if (scale >= 0.125) {
      for (let i = 0; i < 3; i++) {
        const newSphere = createSphere(
          clickedSphere.material.color,
          scale,
          position
        );
        newSphere.velocity = clickedSphere.velocity
          .clone()
          .multiplyScalar(0.005);
        newSphere.velocity.x +=
          Math.abs(Math.random() - 0.95) * 0.0002;
        newSphere.velocity.y +=
          Math.abs(Math.random() - 0.95) * 0.0002;
        newSphere.velocity.z += Math.abs(Math.random() - 0.95) * 0.0002;
        spheres.push(newSphere);
        scene.add(newSphere);
      }
    }

    scene.remove(clickedSphere);
    spheres.splice(spheres.indexOf(clickedSphere), 1);
  }
}





  function createSphere(color, scale, position) {
  const geometry = new THREE.SphereGeometry(scale, 32, 32);
  const material = new THREE.MeshPhongMaterial({ color: color, shininess: 100 });
  const sphere = new THREE.Mesh(geometry, material);
  sphere.scale.set(scale, scale, scale);
  sphere.position.copy(position);

  const direction = new THREE.Vector3(
    (Math.random() - 0.5) * 0.5 * scale,
    (Math.random() - 0.5) * 0.5 * scale,
    (Math.random() - 0.5) * 0.5 * scale
  );

  sphere.position.add(direction);
  return sphere;
}



  function animate() {
    requestAnimationFrame(animate);

    spheres.forEach((sphere) => {
      sphere.rotation.x += 0.01;
      sphere.rotation.y += 0.01;
    });

    spheres.forEach((sphere, index) => {
      sphere.position.add(sphere.velocity);
      spheres.slice(index + 1).forEach((otherSphere) => {
        const distance = sphere.position.distanceTo(otherSphere.position);
        const force =
          (0.0005 * sphere.scale.x * otherSphere.scale.x) /
          distance ** 2;
        const direction = otherSphere.position
          .clone()
          .sub(sphere.position)
          .normalize()
          .multiplyScalar(force);
        otherSphere.velocity.add(direction);
        sphere.velocity.sub(direction);
      });
    });

    spheres.forEach((sphere) => {
      const aspect = window.innerWidth / window.innerHeight;
      const vFov = (camera.fov * Math.PI) / 180;
      const height = 2 * Math.tan(vFov / 2) * camera.position.z;
      const width = height * aspect;
      const halfWidth = width / 2 - 1;
      const halfHeight = height / 2 - 1;

      const halfDepth = 5;

      if (Math.abs(sphere.position.x) + sphere.scale.x > halfWidth) {
        sphere.velocity.x = -sphere.velocity.x;
      }
      if (Math.abs(sphere.position.y) + sphere.scale.y > halfHeight) {
        sphere.velocity.y = -sphere.velocity.y;
      }
      if (Math.abs(sphere.position.z) + sphere.scale.z > halfDepth) {
        sphere.velocity.z = -sphere.velocity.z;
      }
    });

    renderer.render(scene, camera);
  }

  init();
  animate();
</script>
 </body>
</html>
